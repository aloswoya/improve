### 图片隐写

原理(wikipedia)：
> 载体文件（cover file）相对隐秘文件的大小（指数据含量，以比特计）越大，隐藏后者就越加容易。

> 因为这个原因，数字图像（包含有大量的数据）在因特网和其他传媒上被广泛用于隐藏消息。这种方法使用的广泛程度无从查考。例如：一个24位的位图中的每个像素的三个颜色分量（红，绿和蓝）各使用8个比特来表示。如果我们只考虑蓝色的话，就是说有2^8种不同的数值来表示深浅不同的蓝色。而像11111111和11111110这两个值所表示的蓝色，人眼几乎无法区分。因此，这个最低有效位就可以用来存储颜色之外的信息，而且在某种程度上几乎是检测不到的。如果对红色和绿色进行同样的操作，就可以在差不多三个像素中存储一个字节的信息。

> 更正式一点地说，使隐写的信息难以探测的，也就是保证“有效载荷”（需要被隐蔽的信号）对“载体”（即原始的信号）的调制对载体的影响看起来（理想状况下甚至在统计上）可以忽略。这就是说，这种改变应该无法与载体中的噪声加以区别。

>  从信息论的观点来看，这就是说信道的容量必须大于传输“表面上”的信号的需求。这就叫做信道的冗余。对于一幅数字图像，这种冗余可能是成像单元的噪声；对于数字音频，可能是录音或者放大设备所产生的噪声。任何有着模拟放大级的系统都会有所谓的热噪声（或称“1/f”噪声)，这可以用作掩饰。另外，有损压缩技术（如JPEG）会在解压后的数据中引入一些误差，利用这些误差作隐写术用途也是可能的。）

> 隐写术也可以用作数字水印，这里一条消息（往往只是一个标识符）被隐藏到一幅图像中，使得其来源能够被跟踪或校验。


python相关知识
- image.getdata() 得到图片的rgb表示
> JPG文件是RGB编码；PNG文件是RGBA编码，带透明度
```
In[2]: from PIL import Image
In[3]: image = Image.open("py3图片隐写/Desert.jpg")
In[6]: list(image.getdata())[:3]
Out[6]: [(47, 124, 206), (52, 124, 206), (53, 126, 205)]
In[48]: image = Image.open("py3图片隐写/xadmin管理员.png")
In[49]: image.mode
Out[49]: 'RGBA'
In[50]: list(image.getdata())[:3]
Out[50]: [(255, 255, 255, 255), (255, 255, 255, 255), (255, 255, 255, 255)]

```
- 位运算：左移右移(左移乘，右移除)
```
In[7]: 47>>1
Out[7]: 23
In[8]: 47<<1
Out[8]: 94
In[9]: 47<<2
Out[9]: 188
In[10]: 47*4
Out[10]: 188
```
- image元数据
```
image.mode
Out[12]: 'RGB'
image.size
Out[13]: (1024, 768)
```
- 把十进制数字转为二进制
```
In[15]: bin(11)
Out[15]: '0b1011'
In[16]: bin(3)
Out[16]: '0b11'
In[17]: len(bin(3))
Out[17]: 4
In[23]: int('0b11', 2) # 二进制转为十进制数字
Out[23]: 3
```
- 把字符串转为十进制数字（类似于java中的getBytes() toCharArray()）
```
In[28]: bytearray('A', encoding='utf-8')
Out[28]: bytearray(b'A')
In[29]: x = bytearray('A', encoding='utf-8')
In[30]: for i in x:
   ...:     print(i)
   ...:     
65
In[31]: print(x)
bytearray(b'A')
In[32]: len(x)
Out[32]: 1
In[33]: y = bytearray("中文", "utf-8") # 一个中文字符用utf8是3位
In[34]: len(y)
Out[34]: 6
In[35]: for i in y:
   ...:     print(i)
   ...:     
228
184
173
230
150
135
In[36]: y
Out[36]: bytearray(b'\xe4\xb8\xad\xe6\x96\x87')
```
- map(func, iter)方法： 把iter的每一个元素都调用func去执行，返回值形成新的迭代器
```
In[43]: map(constLenBin, [3,4])
Out[43]: <map at 0x6e52b38>
In[44]: '\t'.join(map(constLenBin, [3,4]))
Out[44]: '00000011\t00000100'
In[47]: '\t'.join(map(lambda x: str(x*3), [3, 4]))
Out[47]: '9\t12'
```
- 提取编码信息: 奇数先左移再右移会不等于原来的数字，偶数则相等
```
In[54]: 135>>1<<1
Out[54]: 134
In[55]: 136>>1<<1
Out[55]: 136
In[56]: 135>>1<<1 != 135
Out[56]: True
In[57]: int(135>>1<<1 != 135)
Out[57]: 1
```
- 十进制数字还原为字符
```
In[58]: chr(65)
Out[58]: 'A'
In[59]: chr(66)
Out[59]: 'B'
```

把数据编码进图片的核心：
- 把像素的最低有效位置为0
- 把数据的二进制表示添加到最低有效位，用加法
- 解码的时候，隐写数据如果是1的，那么通过  >>1<<1 是否等于原数字可以提取出来
- 把提取的二进制信息解码还原